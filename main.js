// --- Constants --- const FREE_BASER_ADDRESS = "0x3bA341ea464ae63372Bfe60B572E677CE0d9a3Ba"; const DISPENSER_ADDRESS = "0xB709FafF4f731bfD767354738cB8A38D08a92920"; const PENG_NFT_ADDRESS = "0xB1a58fae5C0E952F64f9433789a350b8ab54D6D0"; const WPOL_ADDRESS = "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270"; const LUSD_ADDRESS = "0xF0FD398Ca09444F771eC968d9cbF073a744A544c"; const POLYGON_CHAIN_ID = 137; const POLYGON_RPCS = { 137: ["https://polygon-rpc.com", "https://rpc-mainnet.matic.network"] }; const POLYGON_NETWORK_CONFIG = { chainId: "0x" + POLYGON_CHAIN_ID.toString(16), chainName: "Polygon PoS", nativeCurrency: { name: "POL", symbol: "POL", decimals: 18 }, rpcUrls: POLYGON_RPCS[137], blockExplorerUrls: ["https://polygonscan.com"] }; // --- Type Definitions --- /** * @typedef {{ chainId: number }} Web3Provider * @typedef {{ eth: { getChainId: () => Promise<number>, getAccounts: () => Promise<string[]> }} Web3Instance * @typedef {{ ok: true, value: T } | { ok: false, error: string }} Result<T> */ /** @type {Web3Provider | null} */ let provider = null; /** @type {Web3Instance | null} */ let web3 = null; /** @type {string | null} */ let connectedAccount = null; // --- Error Handling Utility --- /** * @template T * @param {T} value * @returns {Result<T>} */ function Ok(value) { return { ok: true, value }; } /** * @template T * @param {string} error * @returns {Result<T>} */ function Err(error) { return { ok: false, error }; } // --- Core Blockchain Functions --- /** * @param {string} amount * @param {number} [decimals=18] * @returns {Result<string>} */ function normalize_amount(amount, decimals = 18) { const parsedAmount = parseFloat(amount); if (isNaN(parsedAmount) || parsedAmount <= 0) return Err("Invalid amount"); const normalized = web3.utils.toBN(Math.round(parsedAmount * 10 ** decimals)).toString(); return Ok(normalized); } /** * @param {string} spenderAddress * @param {string} amount * @returns {Promise<Result<boolean>>} */ async function check_approval(spenderAddress, amount) { const wpolContract = new web3.eth.Contract(WPOL_ABI, WPOL_ADDRESS); try { const allowance = await wpolContract.methods.allowance(connectedAccount, spenderAddress).call(); const amountBN = web3.utils.toBN(amount); return Ok(amountBN.lte(web3.utils.toBN(allowance))); } catch (error) { return Err(`Allowance check failed: ${error.message}`); } } /** * @param {string} spenderAddress * @param {string} amount * @returns {Promise<Result<string>>} */ async function approve_wpol(spenderAddress, amount) { const wpolContract = new web3.eth.Contract(WPOL_ABI, WPOL_ADDRESS); try { const tx = await wpolContract.methods.approve(spenderAddress, amount).send({ from: connectedAccount }); return Ok(tx.transactionHash); } catch (error) { return Err(`Approval failed: ${error.message}`); } } /** * @returns {Result<Web3Provider>} */ function init_wallet_connect() { const randomRpc = POLYGON_RPCS[137][Math.floor(Math.random() * POLYGON_RPCS[137].length)]; try { const wcProvider = new WalletConnectProvider({ rpc: { 137: randomRpc }, qrcode: true }); wcProvider.on("error", async (error) => { console.error("Provider error:", error); await switch_rpc(); }); return Ok(wcProvider); } catch (error) { return Err(`Wallet initialization failed: ${error.message}`); } } /** * @returns {Promise<void>} */ async function switch_rpc() { if (!provider) return; const currentRpc = provider.rpc.rpc[137]; const availableRpcs = POLYGON_RPCS[137].filter(rpc => rpc !== currentRpc); if (availableRpcs.length === 0) return; const newRpc = availableRpcs[Math.floor(Math.random() * availableRpcs.length)]; provider.rpc.rpc[137] = newRpc; console.log(`Switched RPC to: ${newRpc}`); try { await provider.disconnect(); await provider.enable(); web3 = new Web3(provider); } catch (error) { console.error("Failed to switch RPC:", error); } } /** * @param {HTMLElement} networkIcon * @returns {Promise<Result<void>>} */ async function handle_network(networkIcon) { const chainId = await web3.eth.getChainId(); const networkStatus = document.getElementById("networkStatus"); const networkError = document.getElementById("networkError"); if (chainId === POLYGON_CHAIN_ID) { networkIcon.outerHTML = `<img id="networkIcon" src="https://i.ibb.co/LDQFMHPS/matic-logo-1.webp" alt="Polygon PoS Icon">`; networkStatus.innerHTML = `<img id="networkIcon" src="https://i.ibb.co/LDQFMHPS/matic-logo-1.webp" alt="Polygon PoS Icon"> Network: Polygon PoS (Chain ID: ${chainId})`; networkError.style.display = "none"; return Ok(undefined); } else { networkIcon.outerHTML = `<span id="networkIcon" class="emoji">üåê</span>`; networkStatus.innerHTML = `<span id="networkIcon" class="emoji">üåê</span> Network: Unknown (Chain ID: ${chainId})`; networkError.style.display = "block"; return Err("Wrong network"); } } /** * @returns {Promise<Result<void>>} */ async function switch_to_polygon() { try { await provider.request({ method: "wallet_switchEthereumChain", params: [{ chainId: POLYGON_NETWORK_CONFIG.chainId }] }); return Ok(undefined); } catch (switchError) { if (switchError.code === 4902) { await provider.request({ method: "wallet_addEthereumChain", params: [POLYGON_NETWORK_CONFIG] }); return Ok(undefined); } return Err(`Network switch failed: ${switchError.message}`); } } /** * @param {HTMLElement} networkIcon * @returns {Promise<Result<string>>} */ async function connect_wallet(networkIcon) { if (AppState.isConnected) return Ok(connectedAccount); const providerResult = init_wallet_connect(); if (!providerResult.ok) return providerResult; provider = providerResult.value; try { await provider.enable(); // This triggers the WalletConnect QR code popup web3 = new Web3(provider); const accounts = await web3.eth.getAccounts(); connectedAccount = accounts[0]; const networkResult = await handle_network(networkIcon); if (!networkResult.ok) { const switchResult = await switch_to_polygon(); if (!switchResult.ok) return switchResult; await handle_network(document.getElementById("networkIcon")); } const pengContract = new web3.eth.Contract(PENG_NFT_ABI, PENG_NFT_ADDRESS); const balance = await pengContract.methods.balanceOf(connectedAccount).call(); document.getElementById("freebaseButton").classList.toggle("hidden", balance < 1); return Ok(connectedAccount); } catch (error) { return Err(`Wallet connection failed: ${error.message}`); } } /** * @returns {Promise<void>} */ async function disconnect_wallet() { if (!provider) return; await provider.disconnect(); provider = null; web3 = null; connectedAccount = null; document.getElementById("freebaseButton").classList.add("hidden"); } /** * @param {HTMLElement} networkIcon * @returns {Promise<Result<string>>} */ async function execute_freebase(networkIcon) { if (!web3 || !connectedAccount) return Err("Wallet not connected"); const networkResult = await handle_network(networkIcon); if (!networkResult.ok) return networkResult; const freebaserContract = new web3.eth.Contract(FREE_BASER_ABI, FREE_BASER_ADDRESS); try { const tx = await freebaserContract.methods.freebase().send({ from: connectedAccount }); return Ok(tx.transactionHash); } catch (error) { return Err(`Freebase failed: ${error.message}`); } } /** * @param {string} amount * @param {HTMLElement} networkIcon * @returns {Promise<Result<string>>} */ async function dispense_wpol(amount, networkIcon) { if (!web3 || !connectedAccount) return Err("Wallet not connected"); const networkResult = await handle_network(networkIcon); if (!networkResult.ok) return networkResult; const normalized = normalize_amount(amount); if (!normalized.ok) return normalized; const approvalResult = await check_approval(DISPENSER_ADDRESS, normalized.value); if (!approvalResult.ok) return approvalResult; if (!approvalResult.value) return Err("Insufficient WPOL approval"); const dispenserContract = new web3.eth.Contract(DISPENSER_ABI, DISPENSER_ADDRESS); try { const tx = await dispenserContract.methods.convert(normalized.value).send({ from: connectedAccount }); return Ok(tx.transactionHash); } catch (error) { return Err(`Dispense failed: ${error.message}`); } } // --- UI Functions --- /** * @param {string} modalId * @returns {void} */ function show_modal(modalId) { document.getElementById(modalId).style.display = "block"; } /** * @param {string} modalId * @returns {void} */ function hide_modal(modalId) { document.getElementById(modalId).style.display = "none"; } const AppState = { isConnected: false, isPolygon: false }; /** * @param {HTMLElement} connectButton * @param {HTMLElement} networkSettings * @param {HTMLElement} networkIcon * @param {HTMLElement} networkStatus * @param {HTMLElement} networkError * @param {HTMLElement[]} buttons * @param {HTMLInputElement[]} inputs * @param {boolean} isConnected * @param {boolean} isPolygon * @param {string | null} [account] * @returns {void} */ function update_ui_state(connectButton, networkSettings, networkIcon, networkStatus, networkError, buttons, inputs, isConnected, isPolygon, account = null) { AppState.isConnected = isConnected; AppState.isPolygon = isPolygon; connectButton.textContent = isConnected && account ? `${account.slice(0, 4)}...${account.slice(-4)}` : "Connect Wallet"; networkSettings.innerHTML = isConnected && isPolygon ? `<img src="https://i.ibb.co/LDQFMHPS/matic-logo-1.webp" alt="Polygon" style="width: 24px; height: 24px;">` : "üåê"; buttons.forEach(btn => btn.disabled = !isConnected || !isPolygon); inputs.forEach(input => input.disabled = !isConnected || !isPolygon); networkError.style.display = isConnected && isPolygon ? "none" : "block"; } /** * @returns {void} */ function toggle_mode() { const body = document.body; const modeToggle = document.getElementById("modeToggle"); const isDark = body.classList.toggle("dark-mode"); modeToggle.textContent = isDark ? "‚òÄÔ∏è" : "üåô"; localStorage.setItem("darkMode", isDark ? "enabled" : "disabled"); } /** * @returns {void} */ function apply_system_mode() { const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches; const savedMode = localStorage.getItem("darkMode"); const body = document.body; const modeToggle = document.getElementById("modeToggle"); if (savedMode === "enabled" || (savedMode === null && prefersDark)) { body.classList.add("dark-mode"); modeToggle.textContent = "‚òÄÔ∏è"; } else { body.classList.remove("dark-mode"); modeToggle.textContent = "üåô"; } } // --- Section Rendering --- /** * @param {HTMLElement} networkIcon * @param {HTMLElement} connectButton * @param {HTMLElement} networkSettings * @param {HTMLElement} networkStatus * @param {HTMLElement} networkError * @param {HTMLElement[]} buttons * @param {HTMLInputElement[]} inputs * @returns {void} */ function render_section2(networkIcon, connectButton, networkSettings, networkStatus, networkError, buttons, inputs) { const tradeButton = document.getElementById("tradeButton"); const dispenseButton = document.getElementById("dispenseButton"); const freebaseButton = document.getElementById("freebaseButton"); const dispenserModal = document.getElementById("dispenserModal"); const dispenserModalClose = document.getElementById("dispenserModalClose"); const dispenserAmount = document.getElementById("dispenserAmount"); const dispenserCost = document.getElementById("dispenserCost"); const dispenserExecute = document.getElementById("dispenserExecute"); const dispenserError = document.getElementById("dispenserError"); const addTouchAndClick = (element, handler) => { element.addEventListener("click", handler); element.addEventListener("touchstart", (e) => { e.preventDefault(); // Prevent default touch behavior handler(e); }); }; addTouchAndClick(tradeButton, async () => { if (!AppState.isConnected) { const connectResult = await connect_wallet(networkIcon); if (!connectResult.ok) { document.getElementById("section2-error").textContent = connectResult.error; document.getElementById("section2-error").style.display = "block"; return; } update_ui_state(connectButton, networkSettings, networkIcon, networkStatus, networkError, buttons, inputs, true, AppState.isPolygon, connectResult.value); } window.open("https://dexscreener.com/polygon/0x8eb0dd7203c2b9294287c1d46c36536e355d23c4", "_blank"); }); addTouchAndClick(dispenseButton, async () => { if (!AppState.isConnected) { const connectResult = await connect_wallet(networkIcon); if (!connectResult.ok) { document.getElementById("section2-error").textContent = connectResult.error; document.getElementById("section2-error").style.display = "block"; return; } update_ui_state(connectButton, networkSettings, networkIcon, networkStatus, networkError, buttons, inputs, true, AppState.isPolygon, connectResult.value); } if (!AppState.isPolygon) return; show_modal("dispenserModal"); const lusdContract = new web3.eth.Contract(LUSD_ABI, LUSD_ADDRESS); const priceRaw = await lusdContract.methods.getPrice().call(); const price = Math.abs(parseFloat(web3.utils.fromWei(priceRaw, "nanoether"))); dispenserAmount.addEventListener("input", async () => { const amount = parseFloat(dispenserAmount.value) || 0; const cost = amount / price; dispenserCost.textContent = cost.toFixed(8); const costNormalized = normalize_amount(cost.toString()); if (costNormalized.ok) { const approvalResult = await check_approval(DISPENSER_ADDRESS, costNormalized.value); dispenserExecute.textContent = approvalResult.ok && approvalResult.value ? "Execute" : "Approve"; } }); addTouchAndClick(dispenserExecute, async () => { const amount = parseFloat(dispenserAmount.value) || 0; const cost = amount / price; const costNormalized = normalize_amount(cost.toString()); if (!costNormalized.ok) { dispenserError.textContent = costNormalized.error; dispenserError.style.display = "block"; return; } if (dispenserExecute.textContent === "Approve") { const approvalResult = await approve_wpol(DISPENSER_ADDRESS, costNormalized.value); if (approvalResult.ok) { dispenserExecute.textContent = "Execute"; dispenserError.style.display = "none"; } else { dispenserError.textContent = approvalResult.error; dispenserError.style.display = "block"; } } else { const dispenseResult = await dispense_wpol(cost.toString(), networkIcon); if (dispenseResult.ok) { hide_modal("dispenserModal"); dispenserError.style.display = "none"; } else { dispenserError.textContent = dispenseResult.error; dispenserError.style.display = "block"; } } }); addTouchAndClick(dispenserModalClose, () => hide_modal("dispenserModal")); addTouchAndClick(dispenserModal, (e) => { if (e.target === dispenserModal) hide_modal("dispenserModal"); }); }); addTouchAndClick(freebaseButton, async () => { if (!AppState.isConnected) { const connectResult = await connect_wallet(networkIcon); if (!connectResult.ok) { document.getElementById("section2-error").textContent = connectResult.error; document.getElementById("section2-error").style.display = "block"; return; } update_ui_state(connectButton, networkSettings, networkIcon, networkStatus, networkError, buttons, inputs, true, AppState.isPolygon, connectResult.value); } if (!AppState.isPolygon) return; const result = await execute_freebase(networkIcon); const errorBox = document.getElementById("section2-error"); errorBox.textContent = result.ok ? "" : result.error; errorBox.style.display = result.ok ? "none" : "block"; }); } /** * @returns {void} */ function init_app() { const connectButton = document.getElementById("connectWallet"); const networkSettings = document.getElementById("networkSettings"); const networkIcon = document.getElementById("networkIcon"); const networkStatus = document.getElementById("networkStatus"); const networkError = document.getElementById("networkError"); const buttons = Array.from(document.getElementsByTagName("button")).filter(btn => btn !== connectButton && btn !== networkSettings); const inputs = Array.from(document.getElementsByTagName("input")); apply_system_mode(); window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", apply_system_mode); const addTouchAndClick = (element, handler) => { element.addEventListener("click", handler); element.addEventListener("touchstart", (e) => { e.preventDefault(); handler(e); }); }; addTouchAndClick(connectButton, async () => { if (!AppState.isConnected) { const result = await connect_wallet(networkIcon); if (result.ok) { const isPolygon = await handle_network(networkIcon); update_ui_state(connectButton, networkSettings, networkIcon, networkStatus, networkError, buttons, inputs, true, isPolygon.ok, result.value); if (!isPolygon.ok) show_modal("networkModal"); } else { document.getElementById("section2-error").textContent = result.error; document.getElementById("section2-error").style.display = "block"; } } else { await disconnect_wallet(); update_ui_state(connectButton, networkSettings, networkIcon, networkStatus, networkError, buttons, inputs, false, false); hide_modal("networkModal"); } }); addTouchAndClick(networkSettings, async () => { if (!AppState.isConnected) { const connectResult = await connect_wallet(networkIcon); if (!connectResult.ok) { document.getElementById("section2-error").textContent = connectResult.error; document.getElementById("section2-error").style.display = "block"; return; } update_ui_state(connectButton, networkSettings, networkIcon, networkStatus, networkError, buttons, inputs, true, AppState.isPolygon, connectResult.value); } if (!AppState.isPolygon) { const switchResult = await switch_to_polygon(); if (switchResult.ok) { const isPolygon = await handle_network(networkIcon); update_ui_state(connectButton, networkSettings, networkIcon, networkStatus, networkError, buttons, inputs, true, isPolygon.ok, connectedAccount); if (isPolygon.ok) hide_modal("networkModal"); } else { document.getElementById("section2-error").textContent = switchResult.error; document.getElementById("section2-error").style.display = "block"; } } }); update_ui_state(connectButton, networkSettings, networkIcon, networkStatus, networkError, buttons, inputs, AppState.isConnected, AppState.isPolygon); render_section2(networkIcon, connectButton, networkSettings, networkStatus, networkError, buttons, inputs); } document.addEventListener("DOMContentLoaded", init_app); // --- ABIs (unchanged for brevity) --- const FREE_BASER_ABI = [/* ... */]; const DISPENSER_ABI = [/* ... */]; const PENG_NFT_ABI = [/* ... */]; const LUSD_ABI = [/* ... */]; const WPOL_ABI = [/* ... */];